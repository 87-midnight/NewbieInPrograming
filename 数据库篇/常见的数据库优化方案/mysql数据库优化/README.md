### mysql数据库优化方案

####为什么要优化
>系统的吞吐量瓶颈往往出现在数据库的访问速度上
 随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢
 数据是存放在磁盘上的，读写速度无法和内存相比

####如何优化
>设计数据库时：数据库表、字段的设计，存储引擎
    利用好MySQL自身提供的功能，如索引等
    横向扩展：MySQL集群、负载均衡、读写分离
    SQL语句的优化（收效甚微）

####字段设计
- 原则：尽量使用整型表示字符串
- 原则：定长和非定长数据类型的选择
- 原则：尽可能选择小的数据类型和指定短的长度
- 原则：尽可能使用 not null
>    - 非null字段的处理要比null字段的处理高效些！且不需要判断是否为null。
>    - null在MySQL中，不好处理，存储需要额外空间，运算也需要特殊的运算符。如select null = null和select null <> null（<>为不等号）有着同样的结果，只能通过is null和is not null来判断字段是否为null。
- 原则：字段注释要完整，见名知意
- 单表字段不宜过多
- 可以预留字段
    - 在使用以上原则之前首先要满足业务需求


####SQL优化
1. exists 和in 的区别

当外查询的数据大时，子查询中的记录较少时，用in;先查询子句，然后把外表一条条的与已得到的查询结果匹配，这个时候子查询还会重新运行一遍；

当子查询的记录较多，外查询的数据较少时，用exists;先对外表做loop循环， 把外表的每一行与子表的查询去匹配，相当于两个嵌套的for循环，得到了正确结果之后就返回相当于break;。

exists对外表做loop循环，in把内表外表做hash连接；

 

2. 尽量少使用* ,*号扫描所有字段

3. 尽量少使用%like，%在最前面会进行全局扫描；

4. having  和 where  

having 和where  都是增加查询条件；

having  一般用于对于分组后 的语句查询,where是普通的条件；

where只能对一条数据设置条件，而having是针对的一组；一般是先where过滤然后在使用having；

5. 尽量使用多表连接，避免子查询

6.尽量在where后面 少用！= < >,这样引擎放弃索引 进行全局扫描 ；

避免在where子句中进行函数操作；

7. from where     的子句执行顺序都是从右往左，从下往上，所以

from  将表数据少的放后面，where条件筛选掉数据多的放后面，groupby 从左往右，放在where后面，

having 消耗资源较大，他是在检出所有资源之后再使用的， 所以尽量少用，他是对最后的结果排序，或者对组添加条件；

https://blog.csdn.net/jie_liang/article/details/77340905

#### 影响数据库查询速度的四个因素
- SQL查询速度
- 网卡流量
- 服务器硬件配置
- 磁盘IO速度

####风险分析

QPS：
>QueriesPerSecond意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。

TPS：
>是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

Tips：最好不要在主库上数据库备份，大型活动前取消这样的计划:

>1. 效率低下的 sql：超高的 QPS与 TPS。
>2. 大量的并发：数据连接数被占满（ max_connection默认 100，一般把连接数设置得大一些）。
>3. 并发量:同一时刻数据库服务器处理的请求数量
>4. 超高的 CPU使用率：CPU资源耗尽出现宕机。
>5. 磁盘 IO：磁盘 IO性能突然下降、大量消耗磁盘性能的计划任务。解决：更快磁盘设备、调整计划任务、做好磁盘维护。

#### 网卡流量：如何避免无法连接数据库的情况
>1. 减少从服务器的数量（从服务器会从主服务器复制日志） 
>2. 进行分级缓存（避免前端大量缓存失效） 
>3. 避免使用 select 进行查询 
>4. 分离业务网络和服务器网络

#### 大表带来的问题（重要）

######大表的特点
>记录行数巨大，单表超千万；表数据文件巨大，超过 10个 G

######大表的危害

>- 慢查询：很难在短时间内过滤出需要的数据
   查询字区分度低 -> 要在大数据量的表中筛选出来其中一部分数据会产生大量的磁盘 io -> 降低磁盘效率
>- DDL的影响：
>    - 建立索引需要很长时间
>    - MySQL-v<5.5 建立索引会锁表 MySQL-v>=5.5 建立索引会造成主从延迟（ mysql建立索引，先在组上执行，再在库上执行）
>    - 修改表结构需要长时间的锁表：会造成长时间的主从延迟('480秒延迟')
######如何处理数据库上的大表
>分库分表把一张大表分成多个小表

######分表难点
>1. 分表主键的选择 
>2. 分表后跨分区数据的查询和统计

####大事务带来的问题（重要）

######什么是事务
>1. 事务是数据库系统区别于其他一切文件系统的重要特性之一
>2. 事务是一组具有原子性的SQL语句，或是一个独立的工作单元
>3. 事务要求符合：原子性、一致性、隔离性、持久性
######事务的 ACID属性
1、原子性（ atomicity)：全部成功，全部回滚失败。银行存取款。

2、一致性（consistent)：银行转账的总金额不变。3、隔离性（isolation)：

**隔离性等级：**
>未提交读( READ UNCOMMITED)脏读,两个事务之间互相可见；已提交读(READ COMMITED)符合隔离性的基本概念,一个事务进行时，其它已提交的事物对于该事务是可见的，即可以获取其它事务提交的数据。可重复读( REPEATABLE READ)InnoDB的默认隔离等级。事务进行时，其它所有事务对其不可见，即多次执行读，得到的结果是一样的！可串行化（SERIALIZABLE） 在读取的每一行数据上都加锁，会造成大量的锁超时和锁征用，严格数据一致性且没有并发是可使用。

查看系统的事务隔离级别：show variables like'%iso%';开启一个新事务：begin;提交一个事务：commit;修改事物的隔离级别：setsession tx_isolation='read-committed';


####大事务
>运行时间长，操作数据比较多的事务；

**风险：**

1、锁定太多数据，造成大量阻塞和锁超时；

2、回滚时所需时间比较长，且数据仍然会处于锁定；

3、如果执行时间长，将造成主从延迟，因为只有当主服务器全部执行完写入日志时，从服务器才会开始进行同步，造成延迟

***解决思路：***

1、避免一次处理太多数据，可以分批次处理；

2、移出不必要的 SELECT操作，保证事务中只有必要的写操作。

####影响性能的几个方面

1、服务器硬件。

2、服务器系统（系统参数优化）。

3、存储引擎。MyISAM：不支持事务，表级锁。InnoDB: 支持事务，支持行级锁，事务 ACID。

4、数据库参数配置。

5、 数据库结构设计和SQL语句。（重点优化）